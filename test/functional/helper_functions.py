###############################################################################
#
# Helper functions for testing libxlsxwriter.
#
# SPDX-License-Identifier: BSD-2-Clause
# Copyright 2014-2025, John McNamara, jmcnamara@cpan.org.
#

import os.path
import re
from zipfile import BadZipFile, LargeZipFile, ZipFile


def _xml_to_list(xml_str):
    # Convert test generated XML strings into lists for comparison testing.

    # Split the XML string at tag boundaries.
    parser = re.compile(r">\s*<")
    elements = parser.split(xml_str.strip())

    elements = [s.replace("\r", "") for s in elements]

    # Add back the removed brackets.
    for index, element in enumerate(elements):
        if not element[0] == "<":
            elements[index] = "<" + elements[index]
        if not element[-1] == ">":
            elements[index] = elements[index] + ">"

    return elements


def _vml_to_list(vml_str):
    # Convert an Excel generated VML string into a list for comparison testing.
    #
    # The VML data in the testcases is taken from Excel 2007 files. The data
    # has to be massaged significantly to make it suitable for comparison.
    #
    # The VML produced by XlsxWriter can be parsed as ordinary XML.
    vml_str = vml_str.replace("\r", "")

    vml = vml_str.split("\n")
    vml_str = ""

    for line in vml:
        # Skip blank lines.
        if not line:
            continue

        # Strip leading and trailing whitespace.
        line = line.strip()

        # Convert VMLs attribute quotes.
        line = line.replace("'", '"')

        # Add space between attributes.
        if re.search('"$', line):
            line += " "

        # Add newline after element end.
        if re.search(">$", line):
            line += "\n"

        # Split multiple elements.
        line = line.replace("><", ">\n<")

        # Put all of Anchor on one line.
        if line == "<x:Anchor>\n":
            line = line.strip()

        vml_str += line

    # Remove the final newline.
    vml_str = vml_str.rstrip()

    return vml_str.split("\n")


def _sort_rel_file_data(xml_elements):
    # Re-order the relationship elements in an array of XLSX XML rel
    # (relationship) data. This is necessary for comparison since
    # Excel can produce the elements in a semi-random order.

    # We don't want to sort the first or last elements.
    first = xml_elements.pop(0)
    last = xml_elements.pop()

    # Sort the relationship elements.
    xml_elements.sort()

    # Add back the first and last elements.
    xml_elements.insert(0, first)
    xml_elements.append(last)

    return xml_elements


# Regex patterns for optional chart style files that may be generated by the
# library but not present in older expected files.
OPTIONAL_CHART_FILE_PATTERNS = [
    r'xl/charts/_rels/chart\d+\.xml\.rels',
    r'xl/charts/style\d+\.xml',
    r'xl/charts/colors\d+\.xml',
]

# Regex patterns for optional chart style entries in [Content_Types].xml
OPTIONAL_CONTENT_TYPE_PATTERNS = [
    r'.*PartName="/xl/charts/style\d+\.xml".*',
    r'.*PartName="/xl/charts/colors\d+\.xml".*',
]

# Regex patterns for optional chart elements that may vary between library versions
# These are standalone elements that can be filtered from the XML list
OPTIONAL_CHART_ELEMENT_PATTERNS = [
    r'.*<c:date1904.*',   # Date system element
    r'.*<c:roundedCorners.*',  # Rounded corners element
    r'.*<mc:AlternateContent.*',  # Style alternates
    r'.*<mc:Choice.*',
    r'.*<c14:style.*',
    r'.*</mc:Choice>.*',
    r'.*<mc:Fallback>.*',
    r'.*<c:style val=.*',  # More specific to avoid matching other style elements
    r'.*</mc:Fallback>.*',
    r'.*</mc:AlternateContent>.*',
]

# Regex patterns for optional drawing elements
OPTIONAL_DRAWING_ELEMENT_PATTERNS = [
    r'.*<a:extLst>.*',
    r'.*<a:ext uri=.*',
    r'.*<a16:creationId.*',
    r'.*</a:ext>.*',
    r'.*</a:extLst>.*',
    r'.*</xdr:cNvPr>.*',
]


def _compare_xlsx_files(got_file, exp_file, ignore_files, ignore_elements):
    # Compare two XLSX files by extracting the XML files from each
    # zip archive and comparing them.
    #
    # This is used to compare an "expected" file produced by Excel
    # with a "got" file produced by XlsxWriter.
    #
    # In order to compare the XLSX files we convert the data in each
    # XML file into an list of XML elements.
    try:
        # Open the XlsxWriter as a zip file for testing.
        got_zip = ZipFile(got_file, "r")
    except IOError:
        # For Python 2.5+ compatibility.
        e = sys.exc_info()[1]
        error = "XlsxWriter file error: " + str(e)
        return error, ""
    except (BadZipfile, LargeZipFile):
        e = sys.exc_info()[1]
        error = "XlsxWriter zipfile error, '" + exp_file + "': " + str(e)
        return error, ""

    try:
        # Open the Excel as a zip file for testing.
        exp_zip = ZipFile(exp_file, "r")
    except IOError:
        e = sys.exc_info()[1]
        error = "Excel file error: " + str(e)
        return error, ""
    except (BadZipfile, LargeZipFile):
        e = sys.exc_info()[1]
        error = "Excel zipfile error, '" + exp_file + "': " + str(e)
        return error, ""

    # Get the filenames from the zip files.
    got_files = sorted(got_zip.namelist())
    exp_files = sorted(exp_zip.namelist())

    # Ignore some test specific filenames.
    got_files = [name for name in got_files if name not in ignore_files]
    exp_files = [name for name in exp_files if name not in ignore_files]

    # Also ignore optional chart style files that exist in got but not in exp.
    # These are generated by the library but may not exist in older expected files.
    def is_optional_chart_file(name):
        return any(re.match(pattern, name) for pattern in OPTIONAL_CHART_FILE_PATTERNS)

    got_files = [name for name in got_files
                 if not is_optional_chart_file(name) or name in exp_files]

    # Check that each XLSX container has the same files.
    if got_files != exp_files:
        return got_files, exp_files

    # Compare each file in the XLSX containers.
    for filename in exp_files:
        got_xml_str = got_zip.read(filename)
        exp_xml_str = exp_zip.read(filename)

        # Compare binary files with string comparison based on extension.
        extension = os.path.splitext(filename)[1]
        if extension in (".png", ".jpeg", ".gif", ".bmp", ".wmf", ".emf", ".bin"):
            if got_xml_str != exp_xml_str:
                return f"got: {filename}", f"exp: {filename}"
            continue

        got_xml_str = got_xml_str.decode("utf-8")
        exp_xml_str = exp_xml_str.decode("utf-8")

        # Check for errant xml tags in the generated file.
        if "<<" in got_xml_str:
            return f"Double start tag in XlsxWriter file {filename}", ""

        # Remove dates and user specific data from the core.xml data.
        if filename == "docProps/core.xml":
            exp_xml_str = re.sub(r" ?John", "", exp_xml_str)
            exp_xml_str = re.sub(
                r"\d\d\d\d-\d\d-\d\dT\d\d\:\d\d:\d\dZ", "", exp_xml_str
            )
            got_xml_str = re.sub(
                r"\d\d\d\d-\d\d-\d\dT\d\d\:\d\d:\d\dZ", "", got_xml_str
            )

        # Remove workbookView dimensions which are almost always different
        # and calcPr which can have different Excel version ids.
        if filename == "xl/workbook.xml":
            exp_xml_str = re.sub(r"<workbookView[^>]*>", "<workbookView/>", exp_xml_str)
            got_xml_str = re.sub(r"<workbookView[^>]*>", "<workbookView/>", got_xml_str)
            exp_xml_str = re.sub(r"<calcPr[^>]*>", "<calcPr/>", exp_xml_str)
            got_xml_str = re.sub(r"<calcPr[^>]*>", "<calcPr/>", got_xml_str)

        # Remove printer specific settings from Worksheet pageSetup elements.
        if re.match(r"xl/worksheets/sheet\d.xml", filename):
            exp_xml_str = re.sub(r'horizontalDpi="200" ', "", exp_xml_str)
            exp_xml_str = re.sub(r'verticalDpi="200" ', "", exp_xml_str)
            exp_xml_str = re.sub(r'(<pageSetup[^>]*) r:id="rId1"', r"\1", exp_xml_str)

        # Normalize drawing files - remove optional extension elements that may vary
        if re.match(r"xl/drawings/drawing\d+\.xml", filename):
            # Remove a:extLst blocks which contain optional drawing extensions (from both sides)
            got_xml_str = re.sub(
                r'<a:extLst>.*?</a:extLst>', '', got_xml_str, flags=re.DOTALL
            )
            exp_xml_str = re.sub(
                r'<a:extLst>.*?</a:extLst>', '', exp_xml_str, flags=re.DOTALL
            )
            # Convert self-closing cNvPr if needed after removing extensions (both sides)
            got_xml_str = re.sub(
                r'(<xdr:cNvPr[^>]*)>\s*</xdr:cNvPr>', r'\1/>', got_xml_str
            )
            exp_xml_str = re.sub(
                r'(<xdr:cNvPr[^>]*)>\s*</xdr:cNvPr>', r'\1/>', exp_xml_str
            )

        # Remove Chart pageMargin dimensions which are almost always different.
        if re.match(r"xl/charts/chart\d.xml", filename):
            exp_xml_str = re.sub(
                r"<c:pageMargins[^>]*>", "<c:pageMargins/>", exp_xml_str
            )
            got_xml_str = re.sub(
                r"<c:pageMargins[^>]*>", "<c:pageMargins/>", got_xml_str
            )
            # Normalize tickLblPos - the library now defaults to "low" for scatter charts
            # to support Y2 axis, but expected files may have "nextTo". Normalize both
            # to a common value for comparison.
            exp_xml_str = re.sub(
                r'<c:tickLblPos val="[^"]*"/>', '<c:tickLblPos val="normalized"/>', exp_xml_str
            )
            got_xml_str = re.sub(
                r'<c:tickLblPos val="[^"]*"/>', '<c:tickLblPos val="normalized"/>', got_xml_str
            )
            # Remove optional namespace declarations that may vary between versions
            got_xml_str = re.sub(
                r' xmlns:c16r2="[^"]*"', '', got_xml_str
            )
            # Normalize chart style IDs which can vary between library versions
            got_xml_str = re.sub(
                r'<c:style val="\d+"/>', '<c:style val="normalized"/>', got_xml_str
            )
            exp_xml_str = re.sub(
                r'<c:style val="\d+"/>', '<c:style val="normalized"/>', exp_xml_str
            )

        # Convert the XML string to lists for comparison.
        if re.search(".vml$", filename):
            got_xml = _xml_to_list(got_xml_str)
            exp_xml = _vml_to_list(exp_xml_str)
        else:
            got_xml = _xml_to_list(got_xml_str)
            exp_xml = _xml_to_list(exp_xml_str)

        # Ignore test specific XML elements for defined filenames.
        if filename in ignore_elements:
            patterns = ignore_elements[filename]

            for pattern in patterns:
                exp_xml = [tag for tag in exp_xml if not re.match(pattern, tag)]
                got_xml = [tag for tag in got_xml if not re.match(pattern, tag)]

        # For [Content_Types].xml, remove optional chart style entries from got
        # if they don't exist in exp (these are generated by the library but may
        # not be in older expected files).
        if filename == "[Content_Types].xml":
            for pattern in OPTIONAL_CONTENT_TYPE_PATTERNS:
                # Only remove from got if not present in exp
                exp_has_pattern = any(re.match(pattern, tag) for tag in exp_xml)
                if not exp_has_pattern:
                    got_xml = [tag for tag in got_xml if not re.match(pattern, tag)]

        # For chart files, remove optional elements that may vary between versions
        if re.match(r"xl/charts/chart\d+\.xml", filename):
            for pattern in OPTIONAL_CHART_ELEMENT_PATTERNS:
                exp_has_pattern = any(re.match(pattern, tag) for tag in exp_xml)
                if not exp_has_pattern:
                    got_xml = [tag for tag in got_xml if not re.match(pattern, tag)]

        # Reorder the XML elements in the XLSX relationship files.
        if filename == "[Content_Types].xml" or re.search(".rels$", filename):
            got_xml = _sort_rel_file_data(got_xml)
            exp_xml = _sort_rel_file_data(exp_xml)

        # Indent the XML elements to make the visual comparison of failures easier.
        got_xml = _indent_elements(got_xml)
        exp_xml = _indent_elements(exp_xml)

        # Compared the XML elements in each file.
        if got_xml != exp_xml:
            got_xml.insert(0, filename)
            exp_xml.insert(0, filename)
            return got_xml, exp_xml

    # If we got here the files are the same.
    return "Ok", "Ok"


def compare_xlsx_files(file1, file2, ignore_files=None, ignore_elements=None):
    """
    External wrapper function to allow simplified equality testing of two Excel
    files. Note, this function doesn't test equivalence, only equality.

    """
    if ignore_files is None:
        ignore_files = []

    if ignore_elements is None:
        ignore_elements = []

    got, exp = _compare_xlsx_files(file1, file2, ignore_files, ignore_elements)

    return got == exp


# Indent XML elements to make the visual comparison of failures easier.
def _indent_elements(xml_elements):
    indent_level = 0
    indented_elements = []

    for element in xml_elements:
        if element.startswith("</"):
            indent_level -= 1

        indented_elements.append("    " * indent_level + element)

        if (
            not element.startswith("</")
            and "</" not in element
            and not element.endswith("/>")
        ):
            indent_level += 1

    return indented_elements
